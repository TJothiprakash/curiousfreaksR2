ğŸ§  LEVEL 1 â€” WARM-UP
âœ… 1. Move Last Node to Front
Input: 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5
Output: 5 â†’ 1 â†’ 2 â†’ 3 â†’ 4

ğŸ¯ Goal: Find the last node, detach it, and point it to head.

âœ… 2. Find Middle Node (no length, one pass)
Use slow/fast pointer â€” standard test.

ğŸ”„ LEVEL 2 â€” TRAVERSAL TWISTS
ğŸ” 3. Reverse Every Alternate K Nodes
Reverse first K, skip K, reverse next K, skip K...

Example:
1â†’2â†’3â†’4â†’5â†’6â†’7â†’8â†’9, K=3
â¡ 3â†’2â†’1â†’4â†’5â†’6â†’9â†’8â†’7

ğŸ”€ 4. Merge Two Sorted Lists (in-place, no dummy)
Merge L1: 1â†’4â†’7, L2: 2â†’3â†’6
â¡ 1â†’2â†’3â†’4â†’6â†’7

ğŸ¯ Bonus: Try it by inserting nodes from L2 into L1

ğŸ§¬ LEVEL 3 â€” POINTER PUZZLES
ğŸª 5. Check if Linked List is Palindrome (O(1) space)
Find mid, reverse second half, compare halves, restore list (optional).

ğŸ§ª 6. Clone a Linked List with Random Pointers
Each node has .next and .random

ğŸ¯ Clone it without HashMap

ğŸª“ 7. Delete N nodes after skipping M nodes
Given M and N, traverse M nodes, then delete next N nodes, repeat.

Example: M=2, N=2
1â†’2â†’3â†’4â†’5â†’6â†’7â†’8
â¡ 1â†’2â†’5â†’6

