| Algorithm                               | Logic / Intuition                                                             | Time Complexity              | Space | Java Mini-Code                                                                                                                                                                                                                                                                                                                                               |
| --------------------------------------- | ----------------------------------------------------------------------------- | ---------------------------- | ----- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Linear Search**                       | Scan each element one by one                                                  | O(n)                         | O(1)  | `for(int i=0;i<n;i++) if(arr[i]==x) return i;`                                                                                                                                                                                                                                                                                                               |
| **Binary Search**                       | Divide sorted array in half each step                                         | O(log n)                     | O(1)  | `while(l<=r){int m=(l+r)/2; if(arr[m]==x) return m; if(arr[m]<x) l=m+1; else r=m-1;}`                                                                                                                                                                                                                                                                        |
| **Jump Search**                         | Skip in √n jumps, then linear search in block                                 | O(√n)                        | O(1)  | `int step=(int)Math.sqrt(n); int i=0; while(i<n && arr[Math.min(i,n-1)]<x) i+=step; for(int j=i-step;j<n && j<=i;j++) if(arr[j]==x) return j;`                                                                                                                                                                                                               |
| **Ternary Search**                      | Divide range into 3 parts (sorted array)                                      | O(log₃ n) ≈ O(log n)         | O(1)  | `while(l<=r){int m1=l+(r-l)/3, m2=r-(r-l)/3; if(arr[m1]==x) return m1; if(arr[m2]==x) return m2; if(x<arr[m1]) r=m1-1; else if(x>arr[m2]) l=m2+1; else {l=m1+1; r=m2-1;}}`                                                                                                                                                                                   |
| **Interpolation Search**                | Like binary but positions based on value distribution (works best if uniform) | O(log log n) avg, O(n) worst | O(1)  | `while(l<=r && x>=arr[l] && x<=arr[r]){int pos=l+((r-l)*(x-arr[l]))/(arr[r]-arr[l]); if(arr[pos]==x) return pos; if(arr[pos]<x) l=pos+1; else r=pos-1;}`                                                                                                                                                                                                     |
| **Fibonacci Search**                    | Uses Fibonacci numbers to split array (sorted)                                | O(log n)                     | O(1)  | `int fibMm2=0,fibMm1=1,fibM=fibMm1+fibMm2; while(fibM<n){fibMm2=fibMm1; fibMm1=fibM; fibM=fibMm1+fibMm2;} int offset=-1; while(fibM>1){int i=Math.min(offset+fibMm2,n-1); if(arr[i]<x){fibM=fibMm1; fibMm1=fibMm2; fibMm2=fibM-fibMm1; offset=i;} else if(arr[i]>x){fibM=fibMm2; fibMm1=fibMm1-fibMm2; fibMm2=fibM-fibMm1;} else return i;}}` *(bit longer)* |
| **Exponential Search**                  | Find range by doubling index, then binary search                              | O(log n)                     | O(1)  | `if(arr[0]==x) return 0; int i=1; while(i<n && arr[i]<=x) i*=2; return binarySearch(arr,i/2,Math.min(i,n-1),x);`                                                                                                                                                                                                                                             |
| **Staircase Search (2D Sorted Matrix)** | Start top-right (or bottom-left), move left if bigger, down if smaller        | O(m+n)                       | O(1)  | `int i=0,j=m-1; while(i<n && j>=0){ if(mat[i][j]==x) return true; if(mat[i][j]>x) j--; else i++; }`                                                                                                                                                                                                                                                          |
